name: Build and Sign

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build'
        required: false

jobs:
  build-macos:
    name: Build macOS
    runs-on: macos-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'yarn'
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install dependencies
        run: |
          yarn install
      
      - name: Build sidecar
        run: |
          yarn build:sidecar-macos
      
      - name: Setup Apple Code Signing
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD || '' }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # V√©rifier que les secrets sont d√©finis
          # APPLE_CERTIFICATE_PASSWORD est optionnel (peut √™tre vide pour .cer)
          # APPLE_TEAM_ID est optionnel car il est d√©j√† dans APPLE_SIGNING_IDENTITY
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_SIGNING_IDENTITY" ]; then
            echo "‚ö†Ô∏è  Secrets Apple non configur√©s - le build ne sera pas sign√©"
            echo "Configurez les secrets dans GitHub ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "Utilisez: bash scripts/prepare-github-secrets.sh pour obtenir les valeurs"
          else
            echo "‚úÖ Variables Apple configur√©es depuis GitHub Secrets"
            echo "APPLE_SIGNING_IDENTITY=${APPLE_SIGNING_IDENTITY}"
            # APPLE_CERTIFICATE_PASSWORD peut √™tre vide pour .cer (ou contenir juste un espace)
            # Normaliser : traiter un espace comme vide
            APPLE_CERTIFICATE_PASSWORD=$(echo "$APPLE_CERTIFICATE_PASSWORD" | tr -d '[:space:]')
            if [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
              echo "APPLE_CERTIFICATE_PASSWORD=(vide - OK pour .cer ou .p12 sans mot de passe)"
            else
              echo "APPLE_CERTIFICATE_PASSWORD=(d√©fini)"
            fi
            # Extraire le Team ID depuis l'identit√© si APPLE_TEAM_ID n'est pas d√©fini
            if [ -z "$APPLE_TEAM_ID" ]; then
              APPLE_TEAM_ID=$(echo "$APPLE_SIGNING_IDENTITY" | sed -n 's/.*(\([A-Z0-9]\{10\}\)).*/\1/p')
              export APPLE_TEAM_ID
              echo "APPLE_TEAM_ID extrait depuis l'identit√©: ${APPLE_TEAM_ID}"
            else
              echo "APPLE_TEAM_ID=${APPLE_TEAM_ID}"
            fi
            
            # Exporter les variables pour Tauri (elles sont d√©j√† dans env, mais on s'assure qu'elles sont export√©es)
            export APPLE_CERTIFICATE
            export APPLE_CERTIFICATE_PASSWORD
            export APPLE_SIGNING_IDENTITY
            export APPLE_TEAM_ID
            
            # Importer le certificat dans le keychain pour que Tauri puisse l'utiliser
            echo "üì¶ Import du certificat dans le keychain..."
            KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
            KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
            
            # Cr√©er un keychain temporaire
            security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            
            # D√©coder et importer le certificat
            echo "$APPLE_CERTIFICATE" | base64 --decode > /tmp/certificate.pem
            
            # Essayer d'importer comme .p12 d'abord (si mot de passe fourni et non vide)
            if [ -n "$APPLE_CERTIFICATE_PASSWORD" ] && [ "$APPLE_CERTIFICATE_PASSWORD" != " " ]; then
              security import /tmp/certificate.pem -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || {
                echo "‚ö†Ô∏è  Import .p12 √©chou√©, tentative avec .cer..."
                security import /tmp/certificate.pem -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security || true
              }
            else
              # Pour .cer, essayer d'importer directement
              security import /tmp/certificate.pem -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security || {
                echo "‚ö†Ô∏è  Import direct √©chou√©, tentative avec format DER..."
                # Essayer en format DER
                openssl x509 -inform PEM -in /tmp/certificate.pem -outform DER -out /tmp/certificate.der 2>/dev/null || true
                security import /tmp/certificate.der -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security || true
              }
            fi
            
            # Configurer le keychain pour codesign
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PATH" "$KEYCHAIN_PATH" || true
            
            # V√©rifier que l'identit√© est disponible
            echo "üîç Identit√©s disponibles dans le keychain:"
            security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
            
            # Ajouter le keychain √† la liste de recherche
            security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
            
            # Nettoyer
            rm -f /tmp/certificate.pem /tmp/certificate.der
            
            echo "‚úÖ Certificat import√© dans le keychain temporaire"
          fi
      
      - name: Build Tauri app
        env:
          # Ne pas passer APPLE_CERTIFICATE si c'est un .cer seul (d√©j√† import√© dans le keychain)
          # Tauri utilisera le certificat depuis le keychain via APPLE_SIGNING_IDENTITY
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # APPLE_CERTIFICATE_PASSWORD normalis√© (espace = vide)
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD || '' }}
        run: |
          yarn tauri build
          # V√©rifier la signature si APPLE_SIGNING_IDENTITY √©tait d√©fini
          if [ -n "$APPLE_SIGNING_IDENTITY" ]; then
            echo "üîç V√©rification de la signature..."
            codesign -dv --verbose=4 src-tauri/target/release/bundle/macos/*.app 2>&1 | head -5 || echo "‚ö†Ô∏è  Impossible de v√©rifier la signature"
          fi
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-app
          path: |
            src-tauri/target/release/bundle/macos/*.app
            src-tauri/target/release/bundle/macos/*.dmg
          retention-days: 30

