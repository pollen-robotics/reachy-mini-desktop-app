name: Release Cross-Platform

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.2.0)'
        required: false
        type: string

jobs:
  build-and-release:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: darwin-aarch64
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: darwin-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: windows-x86_64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'yarn'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies
        run: yarn install

      - name: Build sidecar (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          TARGET_TRIPLET=${{ matrix.target }} bash ./build_sidecar_unix.sh || echo "Sidecar build skipped"

      - name: Build sidecar (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          pwsh -File ./build_sidecar_windows.ps1 || echo "Sidecar build skipped"

      - name: Setup Apple Code Signing (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_SIGNING_IDENTITY" ] || [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
            echo "âŒ Secrets Apple non configurÃ©s - APPLE_CERTIFICATE, APPLE_SIGNING_IDENTITY et APPLE_CERTIFICATE_PASSWORD sont requis"
            exit 1
          fi
          
          echo "âœ… Variables Apple configurÃ©es"
          if [ -z "$APPLE_TEAM_ID" ]; then
            APPLE_TEAM_ID=$(echo "$APPLE_SIGNING_IDENTITY" | sed -n 's/.*(\([A-Z0-9]\{10\}\)).*/\1/p')
            export APPLE_TEAM_ID
          fi
          
          # Importer le certificat .p12 dans le keychain
          echo "ðŸ“¦ Import du certificat .p12 dans le keychain..."
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
          
          # CrÃ©er un keychain temporaire
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Nettoyer le base64 (supprimer espaces, retours Ã  la ligne) puis dÃ©coder
          CLEANED_CERT=$(echo "$APPLE_CERTIFICATE" | tr -d ' \n\r\t')
          
          # Debug: vÃ©rifier la longueur et les premiers caractÃ¨res du base64
          echo "ðŸ” Debug base64:"
          echo "  Longueur: ${#CLEANED_CERT}"
          echo "  Premiers 50 caractÃ¨res: ${CLEANED_CERT:0:50}"
          echo "  Derniers 50 caractÃ¨res: ${CLEANED_CERT: -50}"
          
          # DÃ©coder le base64
          echo "$CLEANED_CERT" | base64 --decode > /tmp/certificate.p12
          
          # VÃ©rifier que le fichier est valide avant l'import
          echo "ðŸ” VÃ©rification du fichier .p12..."
          file /tmp/certificate.p12 || true
          ls -lh /tmp/certificate.p12 || true
          
          # VÃ©rifier avec openssl que le .p12 est valide
          openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout -info 2>&1 | head -5 || {
            echo "âš ï¸  Le fichier .p12 semble invalide ou le mot de passe est incorrect"
          }
          
          # Importer le .p12 dans le keychain
          # Note: security import dÃ©tecte automatiquement le format PKCS12
          security import /tmp/certificate.p12 -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || {
            echo "âŒ Erreur lors de l'import du .p12"
            echo "ðŸ” Tentative alternative avec openssl..."
            # Alternative: convertir en PEM puis importer
            openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -nodes -out /tmp/certificate.pem 2>/dev/null || {
              echo "âŒ Impossible de convertir le .p12"
              exit 1
            }
            # Cette mÃ©thode ne fonctionne pas car on perd la clÃ© privÃ©e dans le keychain
            # Il faut utiliser security import directement avec le .p12
            exit 1
          }
          rm -f /tmp/certificate.p12
          
          # Configurer le keychain pour codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          
          # Ajouter le keychain temporaire en PREMIER dans la liste de recherche (prioritÃ©)
          EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
          security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS
          
          # VÃ©rifier que l'identitÃ© est disponible dans TOUS les keychains
          echo "ðŸ” IdentitÃ©s disponibles dans tous les keychains:"
          security find-identity -v -p codesigning || true
          
          # VÃ©rifier spÃ©cifiquement dans notre keychain
          echo "ðŸ” IdentitÃ©s dans le keychain temporaire:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          
          # Exporter les variables pour les Ã©tapes suivantes
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          echo "âœ… Certificat importÃ© dans le keychain temporaire"
          echo "âœ… Keychain ajoutÃ© Ã  la liste de recherche"

      - name: Setup Tauri Signing Key
        shell: bash
        env:
          TAURI_SIGNING_KEY: ${{ secrets.TAURI_SIGNING_KEY }}
          TAURI_PUBLIC_KEY: ${{ secrets.TAURI_PUBLIC_KEY }}
        run: |
          mkdir -p ~/.tauri
          if [ -n "$TAURI_SIGNING_KEY" ]; then
            CLEANED_KEY=$(echo -n "$TAURI_SIGNING_KEY" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            printf '%s' "$CLEANED_KEY" > ~/.tauri/reachy-mini.key
            chmod 600 ~/.tauri/reachy-mini.key
            if [ -n "$TAURI_PUBLIC_KEY" ]; then
              CLEANED_PUBKEY=$(echo -n "$TAURI_PUBLIC_KEY" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              printf '%s' "$CLEANED_PUBKEY" > ~/.tauri/reachy-mini.key.pub
            else
              PUBKEY=$(grep -o '"pubkey": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
              if [ -n "$PUBKEY" ]; then
                printf '%s' "$PUBKEY" > ~/.tauri/reachy-mini.key.pub
              fi
            fi
          else
            echo "âš ï¸ No signing key provided, generating temporary key..."
            yarn tauri signer generate -w ~/.tauri/reachy-mini.key --ci || true
          fi

      - name: Extract version before build
        id: version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${{ github.event.inputs.version }}
          fi
          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Update version in tauri.conf.json
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            sed -i '' "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
          else
            sed -i.bak "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json && rm -f src-tauri/tauri.conf.json.bak
          fi

      - name: Setup App Store Connect API Key (macOS only)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # VÃ©rifier que toutes les variables de notarisation sont dÃ©finies et valides
          if [ -z "${{ secrets.APPLE_API_KEY_CONTENT }}" ]; then
            echo "âŒ APPLE_API_KEY_CONTENT n'est pas dÃ©fini"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_ISSUER }}" ]; then
            echo "âŒ APPLE_API_ISSUER n'est pas dÃ©fini"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_KEY }}" ]; then
            echo "âŒ APPLE_API_KEY n'est pas dÃ©fini"
            exit 1
          fi
          
          # Nettoyer APPLE_API_ISSUER (supprimer espaces, retours Ã  la ligne, etc.)
          CLEANED_ISSUER=$(echo -n "${{ secrets.APPLE_API_ISSUER }}" | tr -d ' \n\r\t')
          
          # VÃ©rifier que APPLE_API_ISSUER est un UUID valide
          if ! echo "$CLEANED_ISSUER" | grep -qE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'; then
            echo "âŒ APPLE_API_ISSUER n'est pas un UUID valide"
            echo "   Valeur reÃ§ue (longueur: ${#CLEANED_ISSUER}): '${CLEANED_ISSUER}'"
            echo "   Format attendu: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            exit 1
          fi
          
          echo "ðŸ“¦ Configuration de la clÃ© API App Store Connect pour notarisation manuelle..."
          mkdir -p ~/.appstoreconnect
          
          # Nettoyer aussi APPLE_API_KEY_CONTENT
          CLEANED_KEY_CONTENT=$(echo -n "${{ secrets.APPLE_API_KEY_CONTENT }}" | tr -d '\n\r')
          echo "$CLEANED_KEY_CONTENT" > ~/.appstoreconnect/private_key.p8
          chmod 600 ~/.appstoreconnect/private_key.p8
          
          # Nettoyer APPLE_API_KEY aussi
          CLEANED_API_KEY=$(echo -n "${{ secrets.APPLE_API_KEY }}" | tr -d ' \n\r\t')
          
          # Stocker dans GITHUB_ENV pour utilisation dans les Ã©tapes suivantes
          echo "APPLE_API_KEY_PATH=$HOME/.appstoreconnect/private_key.p8" >> $GITHUB_ENV
          echo "APPLE_API_ISSUER=$CLEANED_ISSUER" >> $GITHUB_ENV
          echo "APPLE_API_KEY=$CLEANED_API_KEY" >> $GITHUB_ENV
          echo "âœ… ClÃ© API configurÃ©e pour notarisation manuelle"
          echo "   APPLE_API_ISSUER: ${CLEANED_ISSUER:0:8}... (UUID valide)"

      - name: Build Tauri app (macOS)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # Ne pas passer les variables de notarisation pour Ã©viter la notarisation automatique
          # On la fera manuellement aprÃ¨s avoir signÃ© tous les binaires
        shell: bash
        working-directory: src-tauri
        run: |
          # Builder sans notarisation automatique
          yarn tauri build --target ${{ matrix.target }}

      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        working-directory: src-tauri
        run: |
          yarn tauri build --target ${{ matrix.target }}

      - name: Sign all binaries (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "âŒ App bundle not found: $APP_BUNDLE"
            exit 1
          fi
          chmod +x scripts/sign-all-binaries.sh
          bash scripts/sign-all-binaries.sh "$APP_BUNDLE" "$APPLE_SIGNING_IDENTITY"
          
          # VÃ©rifier que tous les binaires sont signÃ©s
          echo "ðŸ” Verifying all binaries are signed..."
          codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE" || {
            echo "âŒ Some binaries are not properly signed"
            exit 1
          }

      - name: Notarize app (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_API_ISSUER: ${{ env.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ env.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          
          # CrÃ©er un ZIP pour la notarisation
          ZIP_PATH="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.zip"
          cd "$(dirname "$APP_BUNDLE")"
          ditto -c -k --keepParent "$(basename "$APP_BUNDLE")" "$(basename "$ZIP_PATH")"
          
          echo "ðŸ“¦ Submitting app for notarization..."
          xcrun notarytool submit "$ZIP_PATH" \
            --key "$APPLE_API_KEY_PATH" \
            --key-id "$APPLE_API_KEY" \
            --issuer "$APPLE_API_ISSUER" \
            --wait \
            --timeout 30m
          
          echo "âœ… Notarization successful!"
          
          # Staple the notarization ticket
          echo "ðŸ“Ž Stapling notarization ticket..."
          xcrun stapler staple "$APP_BUNDLE"
          xcrun stapler validate "$APP_BUNDLE"

      - name: Create GitHub Release
        if: matrix.os == 'macos-latest' && matrix.target == 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: 'Reachy Mini Control v${{ steps.version.outputs.version }}'
          body: 'See the assets to download this version and install.'
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          files: |
            src-tauri/target/*/release/bundle/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts to existing release
        if: matrix.os != 'macos-latest' || matrix.target != 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: |
            src-tauri/target/${{ matrix.target }}/release/bundle/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build update files
        env:
          RELEASE_URL_BASE: ${{ secrets.RELEASE_URL_BASE || 'https://github.com/pollen-robotics/reachy-mini-desktop-app/releases/download/v' }}
          TARGET_TRIPLET: ${{ matrix.target }}
        shell: bash
        run: |
          export RELEASE_URL_BASE
          export TARGET_TRIPLET
          bash ./scripts/build-update.sh prod "${{ steps.version.outputs.version }}"

      - name: Upload update artifacts
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.platform }}
          path: |
            releases/**
          retention-days: 30

  create-update-manifest:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${{ github.event.inputs.version }}
          fi
          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all update artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: update-*
          merge-multiple: true
          path: update-artifacts

      - name: Merge update.json files into latest.json
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          UPDATE_FILES=$(find update-artifacts -name "update.json" -type f)
          
          if [ -z "$UPDATE_FILES" ]; then
            echo "âš ï¸ No update.json files found"
            exit 0
          fi
          
          FIRST_FILE=$(echo "$UPDATE_FILES" | head -n1)
          VERSION=$(jq -r '.version' "$FIRST_FILE")
          NOTES=$(jq -r '.notes' "$FIRST_FILE")
          PUB_DATE=$(jq -r '.pub_date' "$FIRST_FILE")
          
          MERGED_PLATFORMS="{}"
          for FILE in $UPDATE_FILES; do
            PLATFORM_DATA=$(jq -c '.platforms' "$FILE")
            MERGED_PLATFORMS=$(echo "$MERGED_PLATFORMS" | jq --argjson platforms "$PLATFORM_DATA" '. + $platforms')
          done
          
          MERGED_JSON=$(jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$MERGED_PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}')
          
          echo "$MERGED_JSON" > latest.json
          cat latest.json

      - name: Upload latest.json to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: latest.json
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

