name: Release Cross-Platform

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.2.0)'
        required: false
        type: string

jobs:
  build-and-release:
    permissions:
      contents: write
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: darwin-aarch64
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: darwin-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: windows-x86_64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: linux-x86_64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'yarn'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies
        run: yarn install

      - name: Build sidecar (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          TARGET_TRIPLET=${{ matrix.target }} bash ./scripts/build/build-sidecar-unix.sh || echo "Sidecar build skipped"

      - name: Build sidecar (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          pwsh -File ./scripts/build/build-sidecar-windows.ps1 || echo "Sidecar build skipped"

      - name: Setup Apple Code Signing (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_SIGNING_IDENTITY" ] || [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
            echo "‚ùå Apple secrets not configured - APPLE_CERTIFICATE, APPLE_SIGNING_IDENTITY and APPLE_CERTIFICATE_PASSWORD are required"
            exit 1
          fi
          
          echo "‚úÖ Apple variables configured"
          if [ -z "$APPLE_TEAM_ID" ]; then
            APPLE_TEAM_ID=$(echo "$APPLE_SIGNING_IDENTITY" | sed -n 's/.*(\([A-Z0-9]\{10\}\)).*/\1/p')
            export APPLE_TEAM_ID
          fi
          
          # Import the .p12 certificate into the keychain
          echo "üì¶ Importing .p12 certificate into keychain..."
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
          
          # Create a temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Clean base64 (remove spaces, newlines) then decode
          CLEANED_CERT=$(echo "$APPLE_CERTIFICATE" | tr -d ' \n\r\t')
          
          # Debug: check base64 length and first characters
          echo "üîç Debug base64:"
          echo "  Length: ${#CLEANED_CERT}"
          echo "  First 50 characters: ${CLEANED_CERT:0:50}"
          echo "  Last 50 characters: ${CLEANED_CERT: -50}"
          
          # Decode base64
          echo "$CLEANED_CERT" | base64 --decode > /tmp/certificate.p12
          
          # Verify file is valid before import
          echo "üîç Verifying .p12 file..."
          file /tmp/certificate.p12 || true
          ls -lh /tmp/certificate.p12 || true
          
          # Verify .p12 is valid with openssl
          openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout -info 2>&1 | head -5 || {
            echo "‚ö†Ô∏è  The .p12 file seems invalid or password is incorrect"
          }
          
          # Import .p12 into keychain
          # Note: security import automatically detects PKCS12 format
          security import /tmp/certificate.p12 -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || {
            echo "‚ùå Error importing .p12"
            echo "üîç Trying alternative with openssl..."
            # Alternative: convert to PEM then import
            openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -nodes -out /tmp/certificate.pem 2>/dev/null || {
              echo "‚ùå Unable to convert .p12"
              exit 1
            }
            # This method doesn't work because we lose the private key in the keychain
            # Must use security import directly with .p12
            exit 1
          }
          rm -f /tmp/certificate.p12
          
          # Configure keychain for codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          
          # Add temporary keychain FIRST in search list (priority)
          EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
          security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS
          
          # Verify identity is available in ALL keychains
          echo "üîç Available identities in all keychains:"
          security find-identity -v -p codesigning || true
          
          # Verify specifically in our keychain
          echo "üîç Identities in temporary keychain:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          
          # Export variables for next steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          echo "‚úÖ Certificate imported into temporary keychain"
          echo "‚úÖ Keychain added to search list"

      - name: Setup Tauri Signing Key
        shell: bash
        env:
          TAURI_SIGNING_KEY: ${{ secrets.TAURI_SIGNING_KEY }}
        run: |
          mkdir -p ~/.tauri
          if [ -n "$TAURI_SIGNING_KEY" ]; then
            # The key in GitHub Secrets can be either:
            # 1. Raw format (starts with "untrusted comment: rsign encrypted secret key")
            # 2. Base64-encoded format
            # We detect the format and handle accordingly
            
            # Check if it's raw format (starts with "untrusted comment")
            # Use the first 50 chars to check, avoiding issues with leading whitespace
            FIRST_CHARS=$(printf '%s' "$TAURI_SIGNING_KEY" | head -c 50)
            
            if echo "$FIRST_CHARS" | grep -q "untrusted comment"; then
              # Raw format in GitHub Secrets - encode to base64 for file storage
              # tauri signer expects the key file to be base64-encoded
              # Clean the raw key first (remove leading/trailing whitespace)
              CLEANED_RAW=$(printf '%s' "$TAURI_SIGNING_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              # Encode to base64 and remove ALL newlines/whitespace (tauri signer is strict)
              if [[ "$OSTYPE" == "darwin"* ]]; then
                # macOS: base64 -b 0 or pipe to tr -d '\n'
                printf '%s' "$CLEANED_RAW" | base64 | tr -d '\n\r' > ~/.tauri/reachy-mini.key
              else
                # Linux: base64 -w 0
                printf '%s' "$CLEANED_RAW" | base64 -w 0 | tr -d '\n\r' > ~/.tauri/reachy-mini.key
              fi
              echo "‚úÖ Encoded raw format private key to base64 (for tauri signer)"
            else
              # Already base64 format - use directly (remove ALL whitespace including newlines)
              CLEANED_KEY=$(printf '%s' "$TAURI_SIGNING_KEY" | tr -d '\n\r\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            printf '%s' "$CLEANED_KEY" > ~/.tauri/reachy-mini.key
              echo "‚úÖ Using base64 format private key (from GitHub Secrets)"
            fi
            chmod 600 ~/.tauri/reachy-mini.key
            
            # ‚úÖ Extract public key from tauri.conf.json (standard practice - ensures they match)
            echo "üîë Extracting public key from tauri.conf.json..."
            
            # The public key in tauri.conf.json is base64-encoded
            # We decode it to get the raw public key format that minisign expects
            PUBKEY=$(grep -o '"pubkey": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
            if [ -n "$PUBKEY" ]; then
              # Decode base64 to get raw public key format (what minisign expects)
              echo "$PUBKEY" | base64 -d > ~/.tauri/reachy-mini.key.pub
              echo "‚úÖ Extracted public key from tauri.conf.json (decoded from base64)"
            else
              echo "‚ùå No public key found in tauri.conf.json"
              exit 1
            fi
            
            # ‚úÖ Verify the key pair matches by testing signature
            if [ -f ~/.tauri/reachy-mini.key.pub ]; then
              echo "üîç Verifying key pair match..."
              TEST_FILE="/tmp/test-key-match-$$.txt"
              echo "test" > "$TEST_FILE"
              if yarn tauri signer sign -f ~/.tauri/reachy-mini.key -p "" "$TEST_FILE" 2>/dev/null; then
                # Try to verify with the extracted public key using minisign
                if command -v minisign &> /dev/null && [ -f "$TEST_FILE.sig" ]; then
                  if minisign -V -p ~/.tauri/reachy-mini.key.pub -m "$TEST_FILE" -x "$TEST_FILE.sig" 2>/dev/null; then
                    echo "‚úÖ Key pair verified - public key matches private key"
                  else
                    echo "‚ö†Ô∏è Warning: Public key verification failed - keys may not match"
                    echo "   This could cause 'invalid encoding in minisign data' errors"
                  fi
                fi
                rm -f "$TEST_FILE" "$TEST_FILE.sig" 2>/dev/null || true
              else
                echo "‚ö†Ô∏è Could not test key pair (private key may require password)"
              fi
            fi
            
            # ‚úÖ Verify the private key is valid by attempting a test sign
            echo "üîç Verifying private key validity..."
            TEST_FILE="/tmp/test-sign-verify-$$.txt"
            echo "test" > "$TEST_FILE"
            if yarn tauri signer sign -f ~/.tauri/reachy-mini.key -p "" "$TEST_FILE" 2>/dev/null; then
              echo "‚úÖ Private key is valid and can sign files"
              rm -f "$TEST_FILE" "$TEST_FILE.sig" 2>/dev/null || true
            else
              echo "‚ö†Ô∏è Warning: Could not verify private key (may require password or key mismatch)"
            fi
          else
            echo "‚ö†Ô∏è No signing key provided, generating temporary key..."
            yarn tauri signer generate -w ~/.tauri/reachy-mini.key --ci || true
          fi

      - name: Extract version before build
        id: version
        shell: bash
        run: |
          echo "üîç Extracting version..."
          echo "   GITHUB_REF: $GITHUB_REF"
          echo "   github.event.inputs.version: ${{ github.event.inputs.version }}"
          
          # Try to extract from tag (format: refs/tags/v0.2.15)
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            echo "   No 'v' prefix in tag, trying input..."
            VERSION=${{ github.event.inputs.version }}
          fi
          
          # If still empty, try to extract from tag without 'v' prefix
          if [ -z "$VERSION" ] || [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${GITHUB_REF#refs/tags/}
            if [ "$VERSION" = "$GITHUB_REF" ]; then
              echo "   No tag found, trying tauri.conf.json..."
              VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
            fi
          fi
          
          if [ -z "$VERSION" ]; then
            echo "‚ùå Could not determine version!"
            exit 1
          fi
          
          echo "‚úÖ Version extracted: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update version in tauri.conf.json
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "üìù Updating version in tauri.conf.json to: $VERSION"
          
          # Show current version before update
          CURRENT_VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          echo "   Current version: $CURRENT_VERSION"
          
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            sed -i '' "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
          else
            sed -i.bak "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json && rm -f src-tauri/tauri.conf.json.bak
          fi
          
          # Verify update
          UPDATED_VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          echo "   Updated version: $UPDATED_VERSION"
          
          if [ "$UPDATED_VERSION" != "$VERSION" ]; then
            echo "‚ùå Version update failed! Expected: $VERSION, Got: $UPDATED_VERSION"
            exit 1
          fi
          
          echo "‚úÖ Version updated successfully"

      - name: Setup App Store Connect API Key (macOS only)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # Verify all notarization variables are defined and valid
          if [ -z "${{ secrets.APPLE_API_KEY_CONTENT }}" ]; then
            echo "‚ùå APPLE_API_KEY_CONTENT is not defined"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_ISSUER }}" ]; then
            echo "‚ùå APPLE_API_ISSUER is not defined"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_KEY }}" ]; then
            echo "‚ùå APPLE_API_KEY is not defined"
            exit 1
          fi
          
          # Clean APPLE_API_ISSUER (remove spaces, newlines, etc.)
          CLEANED_ISSUER=$(echo -n "${{ secrets.APPLE_API_ISSUER }}" | tr -d ' \n\r\t')
          
          # Verify APPLE_API_ISSUER is a valid UUID
          if ! echo "$CLEANED_ISSUER" | grep -qE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'; then
            echo "‚ùå APPLE_API_ISSUER is not a valid UUID"
            echo "   Received value (length: ${#CLEANED_ISSUER}): '${CLEANED_ISSUER}'"
            echo "   Expected format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            exit 1
          fi
          
          echo "üì¶ Configuring App Store Connect API key for manual notarization..."
          mkdir -p ~/.appstoreconnect
          
          # Get the secret content
          KEY_CONTENT="${{ secrets.APPLE_API_KEY_CONTENT }}"
          
          # Detect if content is base64-encoded or raw PEM
          # Base64 typically doesn't start with -----BEGIN
          FIRST_CHARS=$(echo "$KEY_CONTENT" | head -c 20 | tr -d ' \n\r\t')
          
          if echo "$FIRST_CHARS" | grep -q "^-----BEGIN"; then
            echo "‚úÖ Detected raw PEM format"
            # Raw PEM format - write directly
            printf '%s' "$KEY_CONTENT" > ~/.appstoreconnect/private_key.p8
          else
            echo "‚úÖ Detected base64-encoded format"
            # Base64 format - decode first
            echo "$KEY_CONTENT" | tr -d ' \n\r\t' | base64 --decode > ~/.appstoreconnect/private_key.p8
          fi
          
          chmod 600 ~/.appstoreconnect/private_key.p8
          
          # Validate the key file using openssl (standard practice)
          echo "üîç Validating private key with openssl..."
          if openssl pkey -in ~/.appstoreconnect/private_key.p8 -noout > /dev/null 2>&1; then
            echo "‚úÖ Private key is valid and parseable by openssl"
          else
            echo "‚ùå Invalid private key file - openssl validation failed"
            echo ""
            echo "üîç Debug info:"
            echo "   File size: $(wc -c < ~/.appstoreconnect/private_key.p8) bytes"
            echo "   First line: $(head -1 ~/.appstoreconnect/private_key.p8)"
            echo "   Last line: $(tail -1 ~/.appstoreconnect/private_key.p8)"
            echo ""
            echo "üí° APPLE_API_KEY_CONTENT can be stored in two formats:"
            echo "   1. Raw PEM: Copy the entire .p8 file content (including BEGIN/END lines)"
            echo "   2. Base64: Encode the .p8 file with: base64 -i Certificates.p8"
            exit 1
          fi
          
          # Clean APPLE_API_KEY as well
          CLEANED_API_KEY=$(echo -n "${{ secrets.APPLE_API_KEY }}" | tr -d ' \n\r\t')
          
          # Store in GITHUB_ENV for use in next steps
          echo "APPLE_API_KEY_PATH=$HOME/.appstoreconnect/private_key.p8" >> $GITHUB_ENV
          echo "APPLE_API_ISSUER=$CLEANED_ISSUER" >> $GITHUB_ENV
          echo "APPLE_API_KEY=$CLEANED_API_KEY" >> $GITHUB_ENV
          echo "‚úÖ API key configured for manual notarization"
          echo "   APPLE_API_ISSUER: ${CLEANED_ISSUER:0:8}... (valid UUID)"

      - name: Build Tauri app (macOS)
        if: matrix.os == 'macos-latest'
        env:
          # Don't pass APPLE_SIGNING_IDENTITY to prevent Tauri from auto-signing
          # We'll sign manually after build with our script that signs ALL binaries
          # signingIdentity is set to "-" in tauri.macos.conf.json to disable auto-signing
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        shell: bash
        working-directory: src-tauri
        run: |
          # Explicitly unset any signing/notarization variables to prevent Tauri from auto-signing/notarizing
          # These might be set in GITHUB_ENV from previous steps
          unset APPLE_SIGNING_IDENTITY || true
          unset APPLE_API_ISSUER || true
          unset APPLE_API_KEY || true
          unset APPLE_API_KEY_PATH || true
          
          # Temporarily remove the signing keychain from search list to prevent Tauri from auto-detecting it
          # We'll add it back for manual signing
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "üîí Temporarily removing signing keychain from search list..."
            EXISTING_KEYCHAINS=$(security list-keychains -d user | grep -v "$KEYCHAIN_PATH" | sed 's/^[[:space:]]*//' | tr '\n' ' ')
            security list-keychains -d user -s $EXISTING_KEYCHAINS || true
          fi
          
          echo "üîç Verifying no auto-signing/notarization variables are set..."
          env | grep -E "APPLE_(SIGNING|API)" || echo "‚úÖ No auto-signing/notarization variables found"
          
          # Build without automatic signing/notarization
          # signingIdentity is set to "-" in tauri.macos.conf.json
          yarn tauri build --target ${{ matrix.target }}
          
          # Restore keychain to search list for manual signing step
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "üîì Restoring signing keychain to search list..."
            EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
            security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS || true
          fi

      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        working-directory: src-tauri
        run: |
          yarn tauri build --target ${{ matrix.target }}

      - name: Build Tauri app (Linux)
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        working-directory: src-tauri
        run: |
          # Install dependencies required for AppImage build
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libgdk-pixbuf2.0-dev \
            libpango1.0-dev \
            libcairo2-dev \
            libglib2.0-dev \
            libx11-dev \
            libxrandr-dev \
            libasound2-dev \
            libxdo-dev \
            libudev-dev \
            build-essential \
            pkg-config \
            libssl-dev \
            curl \
            file \
            libc-bin
          
          # Ensure linuxdeploy can be downloaded (Tauri handles this automatically)
          # Set environment variables for pkg-config if needed
          export PKG_CONFIG_PATH=/usr/lib/pkgconfig:/usr/share/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig
          
          # Clean previous build artifacts to avoid conflicts
          rm -rf target/${{ matrix.target }}/release/bundle
          
          yarn tauri build --target ${{ matrix.target }}

      - name: Sign all binaries (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "‚ùå App bundle not found: $APP_BUNDLE"
            exit 1
          fi
          
          # Ensure signing keychain is in search list for manual signing
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "üîì Ensuring signing keychain is in search list..."
            EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
            if ! echo "$EXISTING_KEYCHAINS" | grep -q "$KEYCHAIN_PATH"; then
              security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS || true
            fi
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          fi
          
          chmod +x scripts/signing/sign-all-binaries.sh
          bash scripts/signing/sign-all-binaries.sh "$APP_BUNDLE" "$APPLE_SIGNING_IDENTITY"
          
          # Verify all binaries are signed
          echo "üîç Verifying all binaries are signed..."
          codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE" || {
            echo "‚ùå Some binaries are not properly signed"
            exit 1
          }

      - name: Install create-dmg (macOS only)
        if: matrix.os == 'macos-latest'
        run: |
          echo "üì¶ Installing create-dmg..."
          brew install create-dmg

      - name: Create DMG installer (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle/macos"
          
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "‚ùå App bundle not found: $APP_BUNDLE"
            exit 1
          fi
          
          # Ensure signing keychain is in search list for DMG signing
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "üîì Ensuring signing keychain is in search list for DMG signing..."
            EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
            if ! echo "$EXISTING_KEYCHAINS" | grep -q "$KEYCHAIN_PATH"; then
              security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS || true
            fi
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          fi
          
          # Create DMG with custom script (uses create-dmg)
          echo "üíø Creating DMG installer with customize-dmg.sh..."
          ARCH_SUFFIX="${{ matrix.target == 'aarch64-apple-darwin' && 'arm64' || 'x64' }}"
          DMG_NAME="Reachy.Mini.Control_${{ steps.version.outputs.version }}_${ARCH_SUFFIX}.dmg"
          DMG_PATH="$BUNDLE_DIR/$DMG_NAME"
          
          # Remove old DMG if exists
          rm -f "$DMG_PATH" "$BUNDLE_DIR"/*.dmg
          
          # Use the customize-dmg.sh script
          # It uses create-dmg which handles background image, icons, and Applications link
          bash scripts/build/customize-dmg.sh \
            "$APP_BUNDLE" \
            "$DMG_PATH" \
            "src-tauri/dmg-assets/background.png" \
            "Reachy Mini Control"
          
          if [ ! -f "$DMG_PATH" ]; then
            echo "‚ùå Failed to create DMG file"
            exit 1
          fi
          
          # Sign the DMG (required before notarization)
          # Use the same signing identity as the app
          echo "‚úçÔ∏è Signing DMG with identity: $APPLE_SIGNING_IDENTITY"
          if ! codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
            --timestamp \
            --options runtime \
            "$DMG_PATH"; then
            echo "‚ùå DMG signing failed"
            echo "   Available identities:"
            security find-identity -v -p codesigning || true
            exit 1
          fi
          
          echo "‚úÖ DMG created and signed: $DMG_NAME ($(du -h "$DMG_PATH" | cut -f1))"
          echo "RELEASE_DMG_PATH=$DMG_PATH" >> $GITHUB_ENV

      - name: Notarize DMG (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_API_ISSUER: ${{ env.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ env.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}
        shell: bash
        run: |
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle/macos"
          ARCH_SUFFIX="${{ matrix.target == 'aarch64-apple-darwin' && 'arm64' || 'x64' }}"
          DMG_NAME="Reachy.Mini.Control_${{ steps.version.outputs.version }}_${ARCH_SUFFIX}.dmg"
          DMG_PATH="$BUNDLE_DIR/$DMG_NAME"
          
          if [ ! -f "$DMG_PATH" ]; then
            echo "‚ùå DMG not found: $DMG_PATH"
            exit 1
          fi
          
          cd "$BUNDLE_DIR"
          
          # Get absolute path for notarytool
          ABS_DMG_PATH="$(pwd)/$DMG_NAME"
          echo "üì¶ Submitting DMG for notarization..."
          echo "   DMG: $ABS_DMG_PATH ($(du -h "$DMG_NAME" | cut -f1))"
          
          NOTARIZATION_OUTPUT=$(xcrun notarytool submit "$ABS_DMG_PATH" \
            --key "$APPLE_API_KEY_PATH" \
            --key-id "$APPLE_API_KEY" \
            --issuer "$APPLE_API_ISSUER" \
            --wait \
            --timeout 30m 2>&1) || NOTARIZATION_EXIT_CODE=$?
          
          echo "$NOTARIZATION_OUTPUT"
          
          # Check if notarization was successful
          if echo "$NOTARIZATION_OUTPUT" | grep -q "status: Accepted"; then
            echo "‚úÖ DMG notarization successful!"
            
            # Staple the notarization ticket to the DMG
            echo "üìé Stapling notarization ticket to DMG..."
            if ! xcrun stapler staple "$DMG_NAME"; then
              echo "‚ùå Failed to staple notarization ticket to DMG"
              exit 1
            fi
            
            # Validate that the ticket was stapled correctly
            echo "üîç Validating stapled ticket..."
            if ! xcrun stapler validate "$DMG_NAME"; then
              echo "‚ùå Ticket validation failed - ticket may not be stapled correctly"
              exit 1
            fi
            echo "‚úÖ Ticket successfully stapled and validated on DMG"
            
            # Also create ZIP as fallback (for users who prefer ZIP)
            # Note: ZIP is not notarized, but contains the signed app
            echo "üì¶ Creating ZIP file as fallback..."
            APP_BUNDLE="Reachy Mini Control.app"
            RELEASE_ZIP_NAME="Reachy.Mini.Control_${{ steps.version.outputs.version }}_${ARCH_SUFFIX}.zip"
            rm -f "$RELEASE_ZIP_NAME"
            ditto -c -k --norsrc --keepParent "$APP_BUNDLE" "$RELEASE_ZIP_NAME"
            echo "‚úÖ Release ZIP created: $RELEASE_ZIP_NAME ($(du -h "$RELEASE_ZIP_NAME" | cut -f1))"
            echo "RELEASE_ZIP_PATH=$BUNDLE_DIR/$RELEASE_ZIP_NAME" >> $GITHUB_ENV
          else
            echo "‚ùå DMG notarization failed!"
            echo ""
            echo "üîç Checking notarization logs..."
            
            # Extract submission ID if available
            SUBMISSION_ID=$(echo "$NOTARIZATION_OUTPUT" | grep -oE "id: [a-f0-9-]+" | head -1 | cut -d' ' -f2 || echo "")
            
            if [ -n "$SUBMISSION_ID" ]; then
              echo "   Submission ID: $SUBMISSION_ID"
              echo "   Fetching logs..."
              xcrun notarytool log "$SUBMISSION_ID" \
                --key "$APPLE_API_KEY_PATH" \
                --key-id "$APPLE_API_KEY" \
                --issuer "$APPLE_API_ISSUER" || true
            fi
            
            exit 1
          fi

      - name: Create GitHub Release
        if: matrix.os == 'macos-latest' && matrix.target == 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: 'Reachy Mini Control v${{ steps.version.outputs.version }}'
          body: 'See the assets to download this version and install.'
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          files: |
            src-tauri/target/*/release/bundle/appimage/*.AppImage
            src-tauri/target/*/release/bundle/msi/*.msi
            src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.dmg
            src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts to existing release
        if: matrix.os != 'macos-latest' || matrix.target != 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: |
            ${{ matrix.os == 'windows-latest' && format('src-tauri/target/{0}/release/bundle/msi/*.msi', matrix.target) || '' }}
            ${{ matrix.os == 'ubuntu-latest' && format('src-tauri/target/{0}/release/bundle/appimage/*.AppImage', matrix.target) || '' }}
            ${{ matrix.os == 'macos-latest' && format('src-tauri/target/{0}/release/bundle/macos/*.dmg', matrix.target) || '' }}
            ${{ matrix.os == 'macos-latest' && format('src-tauri/target/{0}/release/bundle/macos/*.zip', matrix.target) || '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build update files
        env:
          RELEASE_URL_BASE: ${{ secrets.RELEASE_URL_BASE || 'https://github.com/pollen-robotics/reachy-mini-desktop-app/releases/download/v' }}
          TARGET_TRIPLET: ${{ matrix.target }}
        shell: bash
        run: |
          export RELEASE_URL_BASE
          export TARGET_TRIPLET
          bash ./scripts/build/build-update.sh prod "${{ steps.version.outputs.version }}"

      - name: Upload update artifacts
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.platform }}
          path: |
            releases/**
          retention-days: 30

  create-update-manifest:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      actions: read
      pages: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${{ github.event.inputs.version }}
          fi
          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all update artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: update-*
          merge-multiple: true
          path: update-artifacts

      - name: Merge update.json files into latest.json
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          UPDATE_FILES=$(find update-artifacts -name "update.json" -type f)
          
          if [ -z "$UPDATE_FILES" ]; then
            echo "‚ö†Ô∏è No update.json files found"
            exit 0
          fi
          
          FIRST_FILE=$(echo "$UPDATE_FILES" | head -n1)
          VERSION=$(jq -r '.version' "$FIRST_FILE")
          NOTES=$(jq -r '.notes' "$FIRST_FILE")
          PUB_DATE=$(jq -r '.pub_date' "$FIRST_FILE")
          
          MERGED_PLATFORMS="{}"
          for FILE in $UPDATE_FILES; do
            PLATFORM_DATA=$(jq -c '.platforms' "$FILE")
            MERGED_PLATFORMS=$(echo "$MERGED_PLATFORMS" | jq --argjson platforms "$PLATFORM_DATA" '. + $platforms')
          done
          
          MERGED_JSON=$(jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$MERGED_PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}')
          
          # ‚úÖ DRY: Create latest.json in root for release upload
          echo "$MERGED_JSON" > latest.json
          echo "‚úÖ Created latest.json"
          cat latest.json
          
          # ‚úÖ DRY: Create directly in docs/ for GitHub Pages (no copy needed)
          mkdir -p docs
          echo "$MERGED_JSON" > docs/latest.json
          echo "‚úÖ Created docs/latest.json for GitHub Pages"
          
          # Verify both files exist and are valid JSON
          if [ ! -f "latest.json" ] || [ ! -f "docs/latest.json" ]; then
            echo "‚ùå Failed to create latest.json files"
            exit 1
          fi
          
          if ! jq empty latest.json 2>/dev/null || ! jq empty docs/latest.json 2>/dev/null; then
            echo "‚ùå Invalid JSON in latest.json files"
            exit 1
          fi
          
          echo "‚úÖ Verified JSON files are valid"

      - name: Upload latest.json to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: latest.json
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify GitHub Pages file
        # ‚úÖ Robust: Verify file exists and is valid before deployment
        run: |
          if [ ! -f "docs/latest.json" ]; then
            echo "‚ùå docs/latest.json not found, cannot deploy"
            exit 1
          fi
          echo "‚úÖ Verified docs/latest.json exists"
          cat docs/latest.json

      - name: Setup Pages
        # ‚úÖ Standard: Official GitHub action to configure Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact for GitHub Pages
        # ‚úÖ Standard: Official GitHub action to upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: docs

      - name: Deploy to GitHub Pages
        # ‚úÖ Standard: Official GitHub action to deploy Pages
        # ‚úÖ Robust: Fail if deployment fails
        id: deployment
        uses: actions/deploy-pages@v4
        continue-on-error: false

      - name: Verify deployment
        # ‚úÖ Intelligent: Verify that the file is accessible after deployment
        # Note: This may take a few seconds for GitHub Pages to propagate
        run: |
          echo "‚è≥ Waiting for GitHub Pages to propagate (up to 30s)..."
          sleep 5
          
          PAGES_URL="https://pollen-robotics.github.io/reachy-mini-desktop-app/latest.json"
          MAX_RETRIES=6
          RETRY_DELAY=5
          
          for i in $(seq 1 $MAX_RETRIES); do
            if curl -sf "$PAGES_URL" > /dev/null 2>&1; then
              echo "‚úÖ GitHub Pages deployment verified at: $PAGES_URL"
              curl -s "$PAGES_URL" | jq -r '.version' | xargs -I {} echo "   Version deployed: {}"
              exit 0
            fi
            echo "   Attempt $i/$MAX_RETRIES: Not yet available, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done
          
          echo "‚ö†Ô∏è  Warning: Could not verify deployment (may take longer to propagate)"
          echo "   URL: $PAGES_URL"
          # Don't fail the workflow - deployment may still succeed, just needs more time

