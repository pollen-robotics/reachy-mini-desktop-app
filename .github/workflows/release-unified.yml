name: Release Cross-Platform

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.2.0)'
        required: false
        type: string

jobs:
  build-and-release:
    permissions:
      contents: write
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: darwin-aarch64
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: darwin-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: windows-x86_64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: linux-x86_64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'yarn'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies
        run: yarn install

      - name: Build sidecar (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          TARGET_TRIPLET=${{ matrix.target }} bash ./scripts/build/build-sidecar-unix.sh || echo "Sidecar build skipped"

      - name: Build sidecar (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          pwsh -File ./scripts/build/build-sidecar-windows.ps1 || echo "Sidecar build skipped"

      - name: Setup Apple Code Signing (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_SIGNING_IDENTITY" ] || [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
            echo "‚ùå Apple secrets not configured - APPLE_CERTIFICATE, APPLE_SIGNING_IDENTITY and APPLE_CERTIFICATE_PASSWORD are required"
            exit 1
          fi
          
          echo "‚úÖ Apple variables configured"
          if [ -z "$APPLE_TEAM_ID" ]; then
            APPLE_TEAM_ID=$(echo "$APPLE_SIGNING_IDENTITY" | sed -n 's/.*(\([A-Z0-9]\{10\}\)).*/\1/p')
            export APPLE_TEAM_ID
          fi
          
          # Import the .p12 certificate into the keychain
          echo "üì¶ Importing .p12 certificate into keychain..."
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
          
          # Create a temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Clean base64 (remove spaces, newlines) then decode
          CLEANED_CERT=$(echo "$APPLE_CERTIFICATE" | tr -d ' \n\r\t')
          
          # Debug: check base64 length and first characters
          echo "üîç Debug base64:"
          echo "  Length: ${#CLEANED_CERT}"
          echo "  First 50 characters: ${CLEANED_CERT:0:50}"
          echo "  Last 50 characters: ${CLEANED_CERT: -50}"
          
          # Decode base64
          echo "$CLEANED_CERT" | base64 --decode > /tmp/certificate.p12
          
          # Verify file is valid before import
          echo "üîç Verifying .p12 file..."
          file /tmp/certificate.p12 || true
          ls -lh /tmp/certificate.p12 || true
          
          # Verify .p12 is valid with openssl
          openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout -info 2>&1 | head -5 || {
            echo "‚ö†Ô∏è  The .p12 file seems invalid or password is incorrect"
          }
          
          # Import .p12 into keychain
          # Note: security import automatically detects PKCS12 format
          security import /tmp/certificate.p12 -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || {
            echo "‚ùå Error importing .p12"
            echo "üîç Trying alternative with openssl..."
            # Alternative: convert to PEM then import
            openssl pkcs12 -in /tmp/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -nodes -out /tmp/certificate.pem 2>/dev/null || {
              echo "‚ùå Unable to convert .p12"
              exit 1
            }
            # This method doesn't work because we lose the private key in the keychain
            # Must use security import directly with .p12
            exit 1
          }
          rm -f /tmp/certificate.p12
          
          # Configure keychain for codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          
          # Add temporary keychain FIRST in search list (priority)
          EXISTING_KEYCHAINS=$(security list-keychains -d user | sed 's/^[[:space:]]*//' | tr '\n' ' ')
          security list-keychains -d user -s "$KEYCHAIN_PATH" $EXISTING_KEYCHAINS
          
          # Verify identity is available in ALL keychains
          echo "üîç Available identities in all keychains:"
          security find-identity -v -p codesigning || true
          
          # Verify specifically in our keychain
          echo "üîç Identities in temporary keychain:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          
          # Export variables for next steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          echo "‚úÖ Certificate imported into temporary keychain"
          echo "‚úÖ Keychain added to search list"

      - name: Setup Tauri Signing Key
        shell: bash
        env:
          TAURI_SIGNING_KEY: ${{ secrets.TAURI_SIGNING_KEY }}
          TAURI_PUBLIC_KEY: ${{ secrets.TAURI_PUBLIC_KEY }}
        run: |
          mkdir -p ~/.tauri
          if [ -n "$TAURI_SIGNING_KEY" ]; then
            CLEANED_KEY=$(echo -n "$TAURI_SIGNING_KEY" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            printf '%s' "$CLEANED_KEY" > ~/.tauri/reachy-mini.key
            chmod 600 ~/.tauri/reachy-mini.key
            if [ -n "$TAURI_PUBLIC_KEY" ]; then
              CLEANED_PUBKEY=$(echo -n "$TAURI_PUBLIC_KEY" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              printf '%s' "$CLEANED_PUBKEY" > ~/.tauri/reachy-mini.key.pub
            else
              PUBKEY=$(grep -o '"pubkey": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
              if [ -n "$PUBKEY" ]; then
                printf '%s' "$PUBKEY" > ~/.tauri/reachy-mini.key.pub
              fi
            fi
          else
            echo "‚ö†Ô∏è No signing key provided, generating temporary key..."
            yarn tauri signer generate -w ~/.tauri/reachy-mini.key --ci || true
          fi

      - name: Extract version before build
        id: version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${{ github.event.inputs.version }}
          fi
          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Update version in tauri.conf.json
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            sed -i '' "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
          else
            sed -i.bak "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json && rm -f src-tauri/tauri.conf.json.bak
          fi

      - name: Setup App Store Connect API Key (macOS only)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # Verify all notarization variables are defined and valid
          if [ -z "${{ secrets.APPLE_API_KEY_CONTENT }}" ]; then
            echo "‚ùå APPLE_API_KEY_CONTENT is not defined"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_ISSUER }}" ]; then
            echo "‚ùå APPLE_API_ISSUER is not defined"
            exit 1
          fi
          if [ -z "${{ secrets.APPLE_API_KEY }}" ]; then
            echo "‚ùå APPLE_API_KEY is not defined"
            exit 1
          fi
          
          # Clean APPLE_API_ISSUER (remove spaces, newlines, etc.)
          CLEANED_ISSUER=$(echo -n "${{ secrets.APPLE_API_ISSUER }}" | tr -d ' \n\r\t')
          
          # Verify APPLE_API_ISSUER is a valid UUID
          if ! echo "$CLEANED_ISSUER" | grep -qE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'; then
            echo "‚ùå APPLE_API_ISSUER is not a valid UUID"
            echo "   Received value (length: ${#CLEANED_ISSUER}): '${CLEANED_ISSUER}'"
            echo "   Expected format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            exit 1
          fi
          
          echo "üì¶ Configuring App Store Connect API key for manual notarization..."
          mkdir -p ~/.appstoreconnect
          
          # Get the secret content
          KEY_CONTENT="${{ secrets.APPLE_API_KEY_CONTENT }}"
          
          # Detect if content is base64-encoded or raw PEM
          # Base64 typically doesn't start with -----BEGIN
          FIRST_CHARS=$(echo "$KEY_CONTENT" | head -c 20 | tr -d ' \n\r\t')
          
          if echo "$FIRST_CHARS" | grep -q "^-----BEGIN"; then
            echo "‚úÖ Detected raw PEM format"
            # Raw PEM format - write directly
            printf '%s' "$KEY_CONTENT" > ~/.appstoreconnect/private_key.p8
          else
            echo "‚úÖ Detected base64-encoded format"
            # Base64 format - decode first
            echo "$KEY_CONTENT" | tr -d ' \n\r\t' | base64 --decode > ~/.appstoreconnect/private_key.p8
          fi
          
          chmod 600 ~/.appstoreconnect/private_key.p8
          
          # Validate the key file using openssl (standard practice)
          echo "üîç Validating private key with openssl..."
          if openssl pkey -in ~/.appstoreconnect/private_key.p8 -noout > /dev/null 2>&1; then
            echo "‚úÖ Private key is valid and parseable by openssl"
          else
            echo "‚ùå Invalid private key file - openssl validation failed"
            echo ""
            echo "üîç Debug info:"
            echo "   File size: $(wc -c < ~/.appstoreconnect/private_key.p8) bytes"
            echo "   First line: $(head -1 ~/.appstoreconnect/private_key.p8)"
            echo "   Last line: $(tail -1 ~/.appstoreconnect/private_key.p8)"
            echo ""
            echo "üí° APPLE_API_KEY_CONTENT can be stored in two formats:"
            echo "   1. Raw PEM: Copy the entire .p8 file content (including BEGIN/END lines)"
            echo "   2. Base64: Encode the .p8 file with: base64 -i Certificates.p8"
            exit 1
          fi
          
          # Clean APPLE_API_KEY as well
          CLEANED_API_KEY=$(echo -n "${{ secrets.APPLE_API_KEY }}" | tr -d ' \n\r\t')
          
          # Store in GITHUB_ENV for use in next steps
          echo "APPLE_API_KEY_PATH=$HOME/.appstoreconnect/private_key.p8" >> $GITHUB_ENV
          echo "APPLE_API_ISSUER=$CLEANED_ISSUER" >> $GITHUB_ENV
          echo "APPLE_API_KEY=$CLEANED_API_KEY" >> $GITHUB_ENV
          echo "‚úÖ API key configured for manual notarization"
          echo "   APPLE_API_ISSUER: ${CLEANED_ISSUER:0:8}... (valid UUID)"

      - name: Build Tauri app (macOS)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # Don't pass notarization variables to avoid automatic notarization
          # We'll do it manually after signing all binaries
        shell: bash
        working-directory: src-tauri
        run: |
          # Build without automatic notarization
          yarn tauri build --target ${{ matrix.target }}

      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        working-directory: src-tauri
        run: |
          yarn tauri build --target ${{ matrix.target }}

      - name: Build Tauri app (Linux)
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        working-directory: src-tauri
        run: |
          # Install dependencies required for AppImage build
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libgdk-pixbuf2.0-dev \
            libpango1.0-dev \
            libcairo2-dev \
            libglib2.0-dev \
            libx11-dev \
            libxrandr-dev \
            libasound2-dev \
            libxdo-dev \
            build-essential \
            pkg-config \
            libssl-dev \
            curl \
            file \
            libc-bin
          
          # Ensure linuxdeploy can be downloaded (Tauri handles this automatically)
          # Set environment variables for pkg-config if needed
          export PKG_CONFIG_PATH=/usr/lib/pkgconfig:/usr/share/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig
          
          # Clean previous build artifacts to avoid conflicts
          rm -rf target/${{ matrix.target }}/release/bundle
          
          yarn tauri build --target ${{ matrix.target }}

      - name: Sign all binaries (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "‚ùå App bundle not found: $APP_BUNDLE"
            exit 1
          fi
          chmod +x scripts/signing/sign-all-binaries.sh
          bash scripts/signing/sign-all-binaries.sh "$APP_BUNDLE" "$APPLE_SIGNING_IDENTITY"
          
          # Verify all binaries are signed
          echo "üîç Verifying all binaries are signed..."
          codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE" || {
            echo "‚ùå Some binaries are not properly signed"
            exit 1
          }

      - name: Notarize app (macOS only)
        if: matrix.os == 'macos-latest'
        env:
          APPLE_API_ISSUER: ${{ env.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ env.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}
        shell: bash
        run: |
          APP_BUNDLE="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.app"
          
          # Create ZIP for notarization
          ZIP_PATH="src-tauri/target/${{ matrix.target }}/release/bundle/macos/Reachy Mini Control.zip"
          cd "$(dirname "$APP_BUNDLE")"
          ditto -c -k --keepParent "$(basename "$APP_BUNDLE")" "$(basename "$ZIP_PATH")"
          
          echo "üì¶ Submitting app for notarization..."
          xcrun notarytool submit "$ZIP_PATH" \
            --key "$APPLE_API_KEY_PATH" \
            --key-id "$APPLE_API_KEY" \
            --issuer "$APPLE_API_ISSUER" \
            --wait \
            --timeout 30m
          
          echo "‚úÖ Notarization successful!"
          
          # Staple the notarization ticket
          echo "üìé Stapling notarization ticket..."
          xcrun stapler staple "$APP_BUNDLE"
          xcrun stapler validate "$APP_BUNDLE"

      - name: Create GitHub Release
        if: matrix.os == 'macos-latest' && matrix.target == 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: 'Reachy Mini Control v${{ steps.version.outputs.version }}'
          body: 'See the assets to download this version and install.'
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          files: |
            src-tauri/target/*/release/bundle/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts to existing release
        if: matrix.os != 'macos-latest' || matrix.target != 'aarch64-apple-darwin'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: |
            src-tauri/target/${{ matrix.target }}/release/bundle/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build update files
        env:
          RELEASE_URL_BASE: ${{ secrets.RELEASE_URL_BASE || 'https://github.com/pollen-robotics/reachy-mini-desktop-app/releases/download/v' }}
          TARGET_TRIPLET: ${{ matrix.target }}
        shell: bash
        run: |
          export RELEASE_URL_BASE
          export TARGET_TRIPLET
          bash ./scripts/build/build-update.sh prod "${{ steps.version.outputs.version }}"

      - name: Upload update artifacts
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.platform }}
          path: |
            releases/**
          retention-days: 30

  create-update-manifest:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION=${{ github.event.inputs.version }}
          fi
          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all update artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: update-*
          merge-multiple: true
          path: update-artifacts

      - name: Merge update.json files into latest.json
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          UPDATE_FILES=$(find update-artifacts -name "update.json" -type f)
          
          if [ -z "$UPDATE_FILES" ]; then
            echo "‚ö†Ô∏è No update.json files found"
            exit 0
          fi
          
          FIRST_FILE=$(echo "$UPDATE_FILES" | head -n1)
          VERSION=$(jq -r '.version' "$FIRST_FILE")
          NOTES=$(jq -r '.notes' "$FIRST_FILE")
          PUB_DATE=$(jq -r '.pub_date' "$FIRST_FILE")
          
          MERGED_PLATFORMS="{}"
          for FILE in $UPDATE_FILES; do
            PLATFORM_DATA=$(jq -c '.platforms' "$FILE")
            MERGED_PLATFORMS=$(echo "$MERGED_PLATFORMS" | jq --argjson platforms "$PLATFORM_DATA" '. + $platforms')
          done
          
          MERGED_JSON=$(jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$MERGED_PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}')
          
          echo "$MERGED_JSON" > latest.json
          cat latest.json

      - name: Upload latest.json to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: latest.json
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

